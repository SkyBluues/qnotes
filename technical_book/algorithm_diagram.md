## 算法图解

### 一、算法简介

#### 重点

- 二分查找
- 大O表示法

#### 二分查找

```Python
def binary_search(input, target):
  l = 0
  r = len(input) - 1
  while l <= r:
    mid = (l + r) // 2
    guess = input[mid]
    if guess == target:
      return mid
    elif guess < target:
      l = mid + 1
    else:
      r = mid - 1
  return None
```

#### 大O表示法

大O表示法指出了算法的速度有多快，也就是时间复杂度。
大O表示法表达速度的方式是操作数，而不是具体时间。更确切的说，是操作数随着输入数据的数量增加而增长的速度。
大O表示法表示的是最坏情况下的复杂度。
常见的时间复杂度：
- O(logN) 二分查找
- O(N) 顺序查找
- O(N*logN) 快速排序
- O(N*N) 选择排序
- O(N!) 旅行商问题

#### 旅行商问题

问题描述：一个人要前往N个城市，要求是总路程最短。那么需要从 N! 个可能的路径中选一个最短的。

旅行商问题的时间复杂度是 O(n!)

### 二、选择排序

算法描述：对于一个无序数组array，其长度为n。遍历一次数组，选出其中最大的一个值，假设最大值索引为k，将array[k]和array[n-1]交换；第二次选出第二大的值，假设其索引为m，将array[m]和array[n-2]交换。如此反复，直到所有元素有序。

复杂度：n*(n+1)/2 = 1/2 * n^2 + 1/2 * n    =>  O(n^2)

```C++
void selection_sort(int arr[], std::size_t len) {
  if (len < 2) return;
  for (std::size_t i = 0; i < len; ++i) {
    std::size_t smallest_index = i;
    for (std::size_t j = i; j < len; ++j) {
      if (arr[j] < arr[smallest_index]) smallest_index = j;
    }
    int tmp = arr[smallest_index];
    arr[smallest_index] = arr[i];
    arr[i] = tmp;
  }
}
```

```Python
def selection_sort(arr):
  for i in range(len(arr)):
    smallest_index = i
    for j in range(i, len(arr)):
      if arr[smallest_index] > arr[j]:
        smallest_index = j
    tmp = arr[i]
    arr[i] = arr[smallest_index]
    arr[smallest_index] = tmp
  return arr
```

### 三、递归

递归，粗俗的理解就是自己调用自己。

每个递归函数都有两部分：基线条件和递归条件。递归条件指的是函数调用自己，基线条件指的是函数不能再调用自己，从而避免无限递归。

#### 栈

栈，后进先出的数据结构

函数调用栈。函数在运行时，都有自己的调用栈，当函数A调用函数B时，函数A的上下文会被入栈，cpu执行指令切换到函数B的上下文。当函数B执行结束后，会将函数A的上下文出栈，cpu切换到函数A的上下文继续执行。

递归调用时，每次递归都会将当前执行的上下文入栈，并切换到下一个执行的上下文。所以，如果递归深度太深，会导致stackoverflow。

### 四、快速排序

#### 分治

分治（D&C），是一种算法思想。一个大问题，将其分解为若干个子问题，然后解决子问题，再将解决的子问题的结果合并起来，大问题得解。这种思想就是分治。

似乎MapReduce就是分治。

D&C的工作原理：
1. 找出简单的基线条件
2. 确定如何缩小问题的规模，使其符合基线条件

例子：一块土地，长1680，宽640，如何将这块地均匀分成方块，且分出的方块要尽可能大。

#### 快速排序

算法描述：对于一个无序数组array，长度为n。首先选择一个元素x，然后遍历数组，将小于等于x的元素放在x的左边，将大于x的元素放在x的右边，假设此时x的下标为k，然后递归的对array[0:k-1]和array[k+1:n-1]执行上述操作，直到所有元素有序。

```C++
void quick_sort(int arr[], int l, int r) {
  if (l >= r) return;
  int i = l;
  int j = r;
  int piovt = arr[i];
  while (i < j) {
    while (i < j && piovt < arr[j]) --j;
    if (i < j) arr[i++] = arr[j];
    while (i < j && piovt >= arr[i]) ++i;
    if (i < j) arr[j--] = arr[i];
  }
  arr[i] = piovt;
  quick_sort(arr, l, i - 1);
  quick_sort(arr, i + 1, r);
}
```

```Python
def quick_sort(arr):
  if len(arr) < 2:
    return arr

  pivot = arr[0]
  less = [i for i in arr[1:] if i < pivot]
  greater = [x for x in arr[1:] if x >= pivot]
  return quick_sort(less) + [pivot] + quick_sort(greater)
```

#### 大O表示法

快速排序的平均复杂度是O(nlogn)，最坏情况的复杂度是O(n^2)；
归并排序的平均复杂度是O(nlogn)，最坏情况的复杂度是O(nlogn)；

为什么快排会比归并快？虽然两者的复杂度是相同的，但是常数因子快排比归并小，而且快排遇上平均情况的可能性比最坏情况的可能性大得多。

什么情况是快排的最坏情况？当数组有序，每次选择的pivot都是最大值或最小值。

快排的最佳情况也是平均情况，只要每次都随机选择一个数组元素作为基准值，快排的平均运行时间就将为O(nlogn)。

### 散列表

散列表，将输入a通过一个名为哈希的函数映射为b，而且这种映射关系是1对1的。

好的哈希函数应该尽可能将不同的输入映射为不同的输出，但是通常输入的集合比输出的集合大，免不了冲突。解决冲突的方式主要有两种：1.对输入进行再哈希；2.通过链表保存相同哈希的元素。

避免冲突需要有：
- 较低的装载因子
- 良好的散列函数

一个不错的经验：一旦装载因子大于0.7，就调整散列表的长度。

### 广度优先搜索

图模拟一组连接。图由节点和边组成，若边是有方向的，称为有向图；若边没有方向，称为无向图。若节点之间能形成环，称为有环图。无向图两两节点形成一个环。

#### 广度优先搜索

假设在一张图中，要搜索从节点A到节点B的路径，先搜索A的所有邻居节点M1-MN，若没有节点B，则继续从节点M-Mn的邻居中查找，如此反复，直到找到节点B。

### 狄克斯特拉算法

带权重的图称为加权图，不带权重的图称为非加权图。计算非加权图的最短路径，可使用广度优先搜索，计算加权图的最短路径，可使用狄克斯特拉算法。

狄克斯特拉算法只适用于有向无环图（DAG）

如果有负权边，就不能使用狄克斯特拉算法。

算法描述：从节点S到节点T的最短路径
1. 计算节点S到所有节点的路径距离，非邻居节点的距离为无限大
2. 找出从S出发能到达的最小距离的节点M
3. 计算从节点M出发能到达的所有节点的距离，若距离比从S出发的距离小，则更新为更小的值
4. 重复2、3的步骤，直到所有节点都遍历过
5. 找出到达S的最短路径

上述过程没有记录路径，只有距离。
每次更新距离时，都应该同步更新到达该节点的父节点，以便可以在最终计算结果时拿到路径。

### 贪婪算法

背包问题：给定一个容量为C的背包，你可以往背包里装入若干物件，你可选择的物件价值为v1...vn，同时体积为w1...wn。你需要在不超过背包容量的前提下，选择价值最大的物件集合。

集合覆盖问题：有集合S1...Sn，每个集合包含E1...En个元素。现在需要覆盖Em个元素，如何选择集合，使得选中的集合最少，且能完全覆盖Em个元素。

#### 贪婪算法

每次选择能够最大程度满足条件的元素，直到满足最终条件。
以背包问题为例，每次选择剩余物件中，可以装入背包且价值最大的物件。

#### NP完全问题

为了解决集合覆盖问题，必须计算每个可能的集合；为了解决旅行商问题，必须把所有可能的路线都列举出来。若目的地有n个，可选择的路线就有：n!个

旅行商问题和集合覆盖问题都有一些共同之处：需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。

如何判断NP完全问题：
- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢
- 设计“所有组合”的问题通常是NP完全问题
- 不能将问题分解成小问题，必须考虑各种可能的情况。很可能是NP完全问题
- 如果问题涉及序列且难以解决，很可能是NP完全问题
- 如果问题涉及集合且难以解决，很可能是NP完全问题
- 如果问题可以转换为集合覆盖问题和旅行商问题，肯定是NP完全问题

### 动态规划

动态规划先解决子问题，再逐步解决大问题。

没能理解消化。

### KNN

一种最基础的机器学习算法。

分类：在空间中，点A属于什么类别，决定于跟他距离最近的n个点的的类别，这n个点中哪一类占多数，A就属于哪一类。

回归：在空间中，点A的属性值，决定于跟他距离最近的n个点的的属性，A的属性等于这n个点的属性均值。

### Other

- 树：二叉查找树、红黑树、B树、堆
- 反向索引
- 傅里叶变换
- MapReduce
- Bloom Filter
- HyperLogLog